"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyOrUpdateCloudBundle = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const path_1 = require("path");
const axios_1 = require("../utilities/axios");
const debug_logger_1 = require("./debug-logger");
function verifyOrUpdateCloudBundle(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const runnerBundleInstallDirectory = getRunnerBundleInstallDirectory(options);
        const currentBundle = getLatestInstalledRunnerBundle(runnerBundleInstallDirectory);
        if (shouldVerifyInstalledRunnerBundle(runnerBundleInstallDirectory, currentBundle)) {
            const axios = (0, axios_1.createApiAxiosInstance)(options);
            let verifyBundleResponse;
            try {
                verifyBundleResponse = yield verifyCurrentBundle(axios, currentBundle);
            }
            catch (e) {
                (0, debug_logger_1.debugLog)('Could not verify bundle. Resetting validation timer and using previously installed or default runner. Error: ', e);
                writeBundleVerificationLock(runnerBundleInstallDirectory);
                return currentBundle;
            }
            if (verifyBundleResponse.data.valid) {
                (0, debug_logger_1.debugLog)('Currently installed bundle is valid');
                writeBundleVerificationLock(runnerBundleInstallDirectory);
                return currentBundle;
            }
            const { version, url } = verifyBundleResponse.data;
            (0, debug_logger_1.debugLog)('Currently installed bundle is invalid, downloading version', version, ' from ', url);
            return {
                version,
                fullPath: yield downloadAndExtractClientBundle(axios, runnerBundleInstallDirectory, version, url),
            };
        }
        return currentBundle;
    });
}
exports.verifyOrUpdateCloudBundle = verifyOrUpdateCloudBundle;
function findWorkspaceRoot(startPath) {
    let currentPath = (0, path_1.isAbsolute)(startPath) ? startPath : (0, path_1.resolve)(startPath);
    while (currentPath !== (0, path_1.dirname)(currentPath)) {
        const potentialFile = (0, path_1.join)(currentPath, 'nx.json');
        if ((0, fs_1.existsSync)(potentialFile)) {
            return currentPath;
        }
        currentPath = (0, path_1.dirname)(currentPath);
    }
    return null;
}
function getRunnerBundleInstallDirectory(options) {
    var _a;
    const cacheDirectory = (_a = (process.env.NX_CACHE_DIRECTORY || options.cacheDirectory)) !== null && _a !== void 0 ? _a : (0, path_1.join)('node_modules', '.cache', 'nx');
    const runnerBundlePath = (0, path_1.join)(cacheDirectory, 'cloud');
    if ((0, path_1.isAbsolute)(runnerBundlePath)) {
        return runnerBundlePath;
    }
    else {
        const workspaceRoot = findWorkspaceRoot(process.cwd());
        return (0, path_1.join)(workspaceRoot, runnerBundlePath);
    }
}
function getLatestInstalledRunnerBundle(runnerBundleInstallDirectory) {
    if (!(0, fs_1.existsSync)(runnerBundleInstallDirectory)) {
        (0, fs_1.mkdirSync)(runnerBundleInstallDirectory, { recursive: true });
    }
    try {
        const installedBundles = (0, fs_1.readdirSync)(runnerBundleInstallDirectory)
            .filter((potentialDirectory) => {
            return (0, fs_1.statSync)((0, path_1.join)(runnerBundleInstallDirectory, potentialDirectory)).isDirectory();
        })
            .map((fileOrDirectory) => ({
            version: fileOrDirectory,
            fullPath: (0, path_1.join)(runnerBundleInstallDirectory, fileOrDirectory),
        }));
        if (installedBundles.length === 0) {
            // No installed bundles
            return null;
        }
        return installedBundles[0];
    }
    catch (e) {
        console.log('Could not read runner bundle path:', e.message);
        return null;
    }
}
function shouldVerifyInstalledRunnerBundle(runnerBundleInstallDirectory, currentBundle) {
    if (process.env.NX_CLOUD_FORCE_REVALIDATE === 'true') {
        return true;
    }
    // No bundle, need to download anyway
    if (currentBundle != null) {
        (0, debug_logger_1.debugLog)('A local bundle currently exists: ', currentBundle);
        const lastVerification = getLatestBundleVerificationTimestamp(runnerBundleInstallDirectory);
        // Never been verified, need to verify
        if (lastVerification != null) {
            // If last verification was less than 30 minutes ago, return the current installed bundle
            const THIRTY_MINUTES = 30 * 60 * 1000;
            if (Date.now() - lastVerification < THIRTY_MINUTES) {
                (0, debug_logger_1.debugLog)('Last verification was within the past 30 minutes, will not verify this time');
                return false;
            }
            (0, debug_logger_1.debugLog)('Last verification was more than 30 minutes ago, verifying bundle is still valid');
        }
    }
    return true;
}
function verifyCurrentBundle(axios, currentBundle) {
    return __awaiter(this, void 0, void 0, function* () {
        const contentHash = getBundleContentHash(currentBundle);
        const queryParams = currentBundle && contentHash
            ? `?${new URLSearchParams({
                version: currentBundle.version,
                contentHash: contentHash,
            }).toString()}`
            : '';
        return axios.get('/nx-cloud/client/verify' + queryParams);
    });
}
function getLatestBundleVerificationTimestamp(runnerBundleInstallDirectory) {
    const lockfilePath = (0, path_1.join)(runnerBundleInstallDirectory, 'verify.lock');
    if ((0, fs_1.existsSync)(lockfilePath)) {
        const timestampAsString = (0, fs_1.readFileSync)(lockfilePath, 'utf-8');
        let timestampAsNumber;
        try {
            timestampAsNumber = Number(timestampAsString);
            return timestampAsNumber;
        }
        catch (e) {
            return null;
        }
    }
    return null;
}
function writeBundleVerificationLock(runnerBundleInstallDirectory) {
    const lockfilePath = (0, path_1.join)(runnerBundleInstallDirectory, 'verify.lock');
    (0, fs_1.writeFileSync)(lockfilePath, new Date().getTime().toString(), 'utf-8');
}
function getBundleContentHash(bundle) {
    if (bundle == null) {
        return null;
    }
    return hashDirectory(bundle.fullPath);
}
function hashDirectory(dir) {
    const files = (0, fs_1.readdirSync)(dir).sort();
    const hashes = files.map((file) => {
        const filePath = (0, path_1.join)(dir, file);
        const stat = (0, fs_1.statSync)(filePath);
        // If the current path is a directory, recursively hash the contents
        if (stat.isDirectory()) {
            return hashDirectory(filePath);
        }
        // If it's a file, hash the file contents
        const content = (0, fs_1.readFileSync)(filePath);
        return (0, crypto_1.createHash)('sha256').update(content).digest('hex');
    });
    // Hash the combined hashes of the directory's contents
    const combinedHashes = hashes.sort().join('');
    return (0, crypto_1.createHash)('sha256').update(combinedHashes).digest('hex');
}
function downloadAndExtractClientBundle(axios, runnerBundleInstallDirectory, version, url) {
    return __awaiter(this, void 0, void 0, function* () {
        let resp;
        try {
            resp = yield axios.get(url, {
                responseType: 'stream',
            });
        }
        catch (e) {
            console.error('Error while updating Nx Cloud client bundle');
            throw e;
        }
        const bundleExtractLocation = (0, path_1.join)(runnerBundleInstallDirectory, version);
        if (!(0, fs_1.existsSync)(bundleExtractLocation)) {
            (0, fs_1.mkdirSync)(bundleExtractLocation);
        }
        const tar = require('tar');
        const extractStream = resp.data.pipe(tar.x({
            cwd: bundleExtractLocation,
        }));
        return new Promise((res, rej) => {
            extractStream.on('error', (e) => {
                rej(e);
            });
            extractStream.on('close', () => {
                removeOldClientBundles(runnerBundleInstallDirectory, version);
                writeBundleVerificationLock(runnerBundleInstallDirectory);
                res(bundleExtractLocation);
            });
        });
    });
}
function removeOldClientBundles(runnerBundleInstallDirectory, currentInstallVersion) {
    const filesAndFolders = (0, fs_1.readdirSync)(runnerBundleInstallDirectory);
    for (let fileOrFolder of filesAndFolders) {
        const fileOrFolderPath = (0, path_1.join)(runnerBundleInstallDirectory, fileOrFolder);
        if (fileOrFolder !== currentInstallVersion) {
            (0, fs_1.rmSync)(fileOrFolderPath, { recursive: true });
        }
    }
}
//# sourceMappingURL=update-manager.js.map