"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changelogHandler = void 0;
const chalk = require("chalk");
const node_fs_1 = require("node:fs");
const tmp_1 = require("tmp");
const devkit_exports_1 = require("../../devkit-exports");
const git_1 = require("./utils/git");
const github_1 = require("./utils/github");
const launch_editor_1 = require("./utils/launch-editor");
const print_diff_1 = require("./utils/print-diff");
async function changelogHandler(args) {
    /**
     * TODO: allow the prefix and version to be controllable via config as well once we flesh out
     * changelog customization, and how it will interact with independently released projects.
     */
    const tagVersionPrefix = args.tagVersionPrefix ?? 'v';
    const releaseVersion = `${tagVersionPrefix}${args.version}`;
    const githubRemote = (0, github_1.getGitHubRemote)(args.gitRemote);
    const token = await (0, github_1.resolveGithubToken)();
    const githubRequestConfig = {
        repo: githubRemote,
        token,
    };
    const from = args.from || (await (0, git_1.getLastGitTag)());
    if (!from) {
        throw new Error(`Could not determine the previous git tag, please provide and explicit reference using --from`);
    }
    const to = args.to;
    const rawCommits = await (0, git_1.getGitDiff)(from, args.to);
    // Parse as conventional commits
    const commits = (0, git_1.parseCommits)(rawCommits).filter((c) => {
        const type = c.type;
        // Always ignore non user-facing commits for now
        // TODO: allow this filter to be configurable via config in a future release
        if (type === 'feat' || type === 'fix' || type === 'perf') {
            return true;
        }
        return false;
    });
    const initialMarkdown = await (0, github_1.generateMarkdown)(commits, releaseVersion, githubRequestConfig);
    let finalMarkdown = initialMarkdown;
    /**
     * If interactive mode, make the markdown available for the user to modify in their editor of choice,
     * in a similar style to git interactive rebases/merges.
     */
    if (args.interactive) {
        const tmpDir = (0, tmp_1.dirSync)().name;
        const changelogPath = (0, devkit_exports_1.joinPathFragments)(tmpDir, 'c.md');
        (0, node_fs_1.writeFileSync)(changelogPath, initialMarkdown);
        await (0, launch_editor_1.launchEditor)(changelogPath);
        finalMarkdown = (0, node_fs_1.readFileSync)(changelogPath, 'utf-8');
    }
    let existingGithubReleaseForVersion;
    try {
        existingGithubReleaseForVersion = await (0, github_1.getGithubReleaseByTag)(githubRequestConfig, releaseVersion);
    }
    catch (err) {
        if (err.response?.status === 401) {
            devkit_exports_1.output.error({
                title: `Unable to resolve data via the Github API. You can use any of the following options to resolve this:`,
                bodyLines: [
                    '- Set the `GITHUB_TOKEN` or `GH_TOKEN` environment variable to a valid Github token with `repo` scope',
                    '- Have an active session via the official gh CLI tool (https://cli.github.com) in your current terminal',
                ],
            });
            process.exit(1);
        }
        if (err.response?.status === 404) {
            // No existing release found, this is fine
        }
        else {
            // Rethrow unknown errors for now
            throw err;
        }
    }
    const changesRangeText = to === 'HEAD' ? `since ${from}` : `between ${from} and ${to}`;
    if (existingGithubReleaseForVersion) {
        devkit_exports_1.output.log({
            title: `Found existing Github release for ${chalk.white(releaseVersion)}, regenerating with changes ${chalk.cyan(changesRangeText)}`,
        });
    }
    else {
        devkit_exports_1.output.log({
            title: `Creating a new Github release for ${chalk.white(releaseVersion)}, including changes ${chalk.cyan(changesRangeText)}`,
        });
    }
    printReleaseLog(releaseVersion, githubRemote, args.dryRun, finalMarkdown, existingGithubReleaseForVersion);
    if (args.dryRun) {
        devkit_exports_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
    }
    else {
        await (0, github_1.createOrUpdateGithubRelease)(githubRequestConfig, {
            version: releaseVersion,
            body: finalMarkdown,
        }, existingGithubReleaseForVersion);
    }
    process.exit(0);
}
exports.changelogHandler = changelogHandler;
function printReleaseLog(releaseVersion, githubRemote, isDryRun, finalMarkdown, existingGithubReleaseForVersion) {
    const logTitle = `https://github.com/${githubRemote}/releases/tag/${releaseVersion}`;
    if (existingGithubReleaseForVersion) {
        console.error(`${chalk.white('UPDATE')} ${logTitle}${isDryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
    }
    else {
        console.error(`${chalk.green('CREATE')} ${logTitle}${isDryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
    }
    console.log('');
    (0, print_diff_1.printDiff)('', finalMarkdown);
}
