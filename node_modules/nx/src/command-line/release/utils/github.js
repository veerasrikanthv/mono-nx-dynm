"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCommit = exports.getGithubReleaseByTag = exports.resolveGithubToken = exports.generateMarkdown = exports.createOrUpdateGithubRelease = exports.getGitHubRemote = void 0;
const chalk = require("chalk");
const node_child_process_1 = require("node:child_process");
const node_fs_1 = require("node:fs");
const node_os_1 = require("node:os");
const devkit_exports_1 = require("../../../devkit-exports");
// axios types and values don't seem to match
const _axios = require("axios");
const axios = _axios;
function getGitHubRemote(remoteName = 'origin') {
    try {
        const remoteUrl = (0, node_child_process_1.execSync)(`git remote get-url ${remoteName}`, {
            encoding: 'utf8',
        }).trim();
        // Extract the 'user/repo' part from the URL
        const regex = /github\.com[/:]([\w-]+\/[\w-]+)\.git/;
        const match = remoteUrl.match(regex);
        if (match && match[1]) {
            return match[1];
        }
        else {
            throw new Error(`Could not extract "user/repo" data from the resolved remote URL: ${remoteUrl}`);
        }
    }
    catch (error) {
        console.error('Error getting GitHub remote:', error.message);
        return null;
    }
}
exports.getGitHubRemote = getGitHubRemote;
async function createOrUpdateGithubRelease(githubRequestConfig, release, existingGithubReleaseForVersion) {
    const result = await syncGithubRelease(githubRequestConfig, release, existingGithubReleaseForVersion);
    /**
     * If something went wrong POSTing to Github we can still pre-populate the web form on github.com
     * to allow the user to manually complete the release.
     */
    if (result.status === 'manual') {
        if (result.error) {
            console.error(result.error);
            process.exitCode = 1;
        }
        const open = require('open');
        await open(result.url)
            .then(() => {
            console.info(`Follow up in the browser to manually create the release.`);
        })
            .catch(() => {
            console.info(`Open this link to manually create a release: \n` +
                chalk.underline(chalk.cyan(result.url)) +
                '\n');
        });
    }
    else {
        devkit_exports_1.output.success({
            title: `Successfully ${existingGithubReleaseForVersion ? 'updated' : 'created'} release ${chalk.bold(release.version)} on Github:`,
            bodyLines: [result.url],
        });
    }
}
exports.createOrUpdateGithubRelease = createOrUpdateGithubRelease;
// TODO: allow this to be configurable via config in a future release
async function generateMarkdown(commits, releaseVersion, githubRequestConfig) {
    const typeGroups = groupBy(commits, 'type');
    const markdown = [];
    const breakingChanges = [];
    const commitTypes = {
        feat: { title: '🚀 Features' },
        perf: { title: '🔥 Performance' },
        fix: { title: '🩹 Fixes' },
        refactor: { title: '💅 Refactors' },
        docs: { title: '📖 Documentation' },
        build: { title: '📦 Build' },
        types: { title: '🌊 Types' },
        chore: { title: '🏡 Chore' },
        examples: { title: '🏀 Examples' },
        test: { title: '✅ Tests' },
        style: { title: '🎨 Styles' },
        ci: { title: '🤖 CI' },
    };
    // Version Title
    markdown.push('', `## ${releaseVersion}`, '');
    for (const type of Object.keys(commitTypes)) {
        const group = typeGroups[type];
        if (!group || group.length === 0) {
            continue;
        }
        markdown.push('', '### ' + commitTypes[type].title, '');
        for (const commit of group.reverse()) {
            const line = formatCommit(commit, githubRequestConfig);
            markdown.push(line);
            if (commit.isBreaking) {
                breakingChanges.push(line);
            }
        }
    }
    if (breakingChanges.length > 0) {
        markdown.push('', '#### ⚠️  Breaking Changes', '', ...breakingChanges);
    }
    const _authors = new Map();
    for (const commit of commits) {
        if (!commit.author) {
            continue;
        }
        const name = formatName(commit.author.name);
        if (!name || name.includes('[bot]')) {
            continue;
        }
        if (_authors.has(name)) {
            const entry = _authors.get(name);
            entry.email.add(commit.author.email);
        }
        else {
            _authors.set(name, { email: new Set([commit.author.email]) });
        }
    }
    // Try to map authors to github usernames
    await Promise.all([..._authors.keys()].map(async (authorName) => {
        const meta = _authors.get(authorName);
        for (const email of meta.email) {
            // For these pseudo-anonymized emails we can just extract the Github username from before the @
            if (email.endsWith('@users.noreply.github.com')) {
                meta.github = email.split('@')[0];
                break;
            }
            // Look up any other emails against the ungh.cc API
            const { data } = await axios
                .get(`https://ungh.cc/users/find/${email}`)
                .catch(() => ({ data: { user: null } }));
            if (data?.user) {
                meta.github = data.user.username;
                break;
            }
        }
    }));
    const authors = [..._authors.entries()].map((e) => ({ name: e[0], ...e[1] }));
    if (authors.length > 0) {
        markdown.push('', '### ' + '❤️  Thank You', '', ...authors.map((i) => {
            const _email = [...i.email].find((e) => !e.includes('noreply.github.com'));
            const email = _email ? `<${_email}>` : '';
            const github = i.github ? `@${i.github}` : '';
            return `- ${i.name} ${github || email}`;
        }));
    }
    return markdown.join('\n').trim();
}
exports.generateMarkdown = generateMarkdown;
async function syncGithubRelease(githubRequestConfig, release, existingGithubReleaseForVersion) {
    const ghRelease = {
        tag_name: release.version,
        name: release.version,
        body: release.body,
    };
    try {
        const newGhRelease = await (existingGithubReleaseForVersion
            ? updateGithubRelease(githubRequestConfig, existingGithubReleaseForVersion.id, ghRelease)
            : createGithubRelease(githubRequestConfig, ghRelease));
        return {
            status: existingGithubReleaseForVersion ? 'updated' : 'created',
            id: newGhRelease.id,
            url: newGhRelease.html_url,
        };
    }
    catch (error) {
        return {
            status: 'manual',
            error,
            url: githubNewReleaseURL(githubRequestConfig, release),
        };
    }
}
async function resolveGithubToken() {
    // Try and resolve from the environment
    const tokenFromEnv = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
    if (tokenFromEnv) {
        return tokenFromEnv;
    }
    // Try and resolve from gh CLI installation
    const ghCLIPath = (0, devkit_exports_1.joinPathFragments)(process.env.XDG_CONFIG_HOME || (0, devkit_exports_1.joinPathFragments)((0, node_os_1.homedir)(), '.config'), 'gh', 'hosts.yml');
    if ((0, node_fs_1.existsSync)(ghCLIPath)) {
        const yamlContents = await node_fs_1.promises.readFile(ghCLIPath, 'utf8');
        const { load } = require('@zkochan/js-yaml');
        const ghCLIConfig = load(yamlContents);
        return ghCLIConfig['github.com'].oauth_token;
    }
    return null;
}
exports.resolveGithubToken = resolveGithubToken;
async function getGithubReleaseByTag(config, tag) {
    return await makeGithubRequest(config, `/repos/${config.repo}/releases/tags/${tag}`, {});
}
exports.getGithubReleaseByTag = getGithubReleaseByTag;
async function makeGithubRequest(config, url, opts = {}) {
    return (await axios(url, {
        ...opts,
        baseURL: 'https://api.github.com',
        headers: {
            ...opts.headers,
            Authorization: config.token ? `Bearer ${config.token}` : undefined,
        },
    })).data;
}
async function createGithubRelease(config, body) {
    return await makeGithubRequest(config, `/repos/${config.repo}/releases`, {
        method: 'POST',
        data: body,
    });
}
async function updateGithubRelease(config, id, body) {
    return await makeGithubRequest(config, `/repos/${config.repo}/releases/${id}`, {
        method: 'PATCH',
        data: body,
    });
}
function githubNewReleaseURL(config, release) {
    return `https://github.com/${config.repo}/releases/new?tag=v${release.version}&title=v${release.version}&body=${encodeURIComponent(release.body)}`;
}
const providerToRefSpec = {
    github: { 'pull-request': 'pull', hash: 'commit', issue: 'issues' },
};
function formatReference(ref, githubRequestConfig) {
    const refSpec = providerToRefSpec['github'];
    return `[${ref.value}](https://github.com/${githubRequestConfig.repo}/${refSpec[ref.type]}/${ref.value.replace(/^#/, '')})`;
}
function formatCommit(commit, githubRequestConfig) {
    return ('- ' +
        (commit.scope ? `**${commit.scope.trim()}:** ` : '') +
        (commit.isBreaking ? '⚠️  ' : '') +
        commit.description +
        formatReferences(commit.references, githubRequestConfig));
}
exports.formatCommit = formatCommit;
function formatReferences(references, githubRequestConfig) {
    const pr = references.filter((ref) => ref.type === 'pull-request');
    const issue = references.filter((ref) => ref.type === 'issue');
    if (pr.length > 0 || issue.length > 0) {
        return (' (' +
            [...pr, ...issue]
                .map((ref) => formatReference(ref, githubRequestConfig))
                .join(', ') +
            ')');
    }
    if (references.length > 0) {
        return ' (' + formatReference(references[0], githubRequestConfig) + ')';
    }
    return '';
}
function formatName(name = '') {
    return name
        .split(' ')
        .map((p) => p.trim())
        .join(' ');
}
function groupBy(items, key) {
    const groups = {};
    for (const item of items) {
        groups[item[key]] = groups[item[key]] || [];
        groups[item[key]].push(item);
    }
    return groups;
}
