"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPluginImport = exports.addIgnoresToLintConfig = exports.addPluginsToLintConfig = exports.addExtendsToLintConfig = exports.replaceOverridesInLintConfig = exports.lintConfigHasOverride = exports.updateOverrideInLintConfig = exports.addOverrideToLintConfig = exports.updateRelativePathsInConfig = exports.isEslintConfigSupported = exports.findEslintFile = exports.baseEsLintFlatConfigFile = exports.baseEsLintConfigFile = exports.eslintConfigFileWhitelist = void 0;
const devkit_1 = require("@nx/devkit");
const flat_config_1 = require("../../utils/flat-config");
const ast_utils_1 = require("./flat-config/ast-utils");
exports.eslintConfigFileWhitelist = [
    '.eslintrc',
    '.eslintrc.js',
    '.eslintrc.cjs',
    '.eslintrc.yaml',
    '.eslintrc.yml',
    '.eslintrc.json',
    'eslint.config.js',
];
exports.baseEsLintConfigFile = '.eslintrc.base.json';
exports.baseEsLintFlatConfigFile = 'eslint.base.config.js';
function findEslintFile(tree, projectRoot = '') {
    if (projectRoot === '' && tree.exists(exports.baseEsLintConfigFile)) {
        return exports.baseEsLintConfigFile;
    }
    if (projectRoot === '' && tree.exists(exports.baseEsLintFlatConfigFile)) {
        return exports.baseEsLintFlatConfigFile;
    }
    for (const file of exports.eslintConfigFileWhitelist) {
        if (tree.exists((0, devkit_1.joinPathFragments)(projectRoot, file))) {
            return file;
        }
    }
    return null;
}
exports.findEslintFile = findEslintFile;
function isEslintConfigSupported(tree, projectRoot = '') {
    const eslintFile = findEslintFile(tree, projectRoot);
    if (!eslintFile) {
        return false;
    }
    return eslintFile.endsWith('.json') || eslintFile.endsWith('.config.js');
}
exports.isEslintConfigSupported = isEslintConfigSupported;
function updateRelativePathsInConfig(tree, sourcePath, destinationPath) {
    if (sourcePath === destinationPath ||
        !isEslintConfigSupported(tree, destinationPath)) {
        return;
    }
    const configPath = (0, devkit_1.joinPathFragments)(destinationPath, findEslintFile(tree, destinationPath));
    const offset = (0, devkit_1.offsetFromRoot)(destinationPath);
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const config = tree.read(configPath, 'utf-8');
        tree.write(configPath, replaceFlatConfigPaths(config, sourcePath, offset, destinationPath));
    }
    else {
        (0, devkit_1.updateJson)(tree, configPath, (json) => {
            if (typeof json.extends === 'string') {
                json.extends = offsetFilePath(sourcePath, json.extends, offset);
            }
            else if (json.extends) {
                json.extends = json.extends.map((extend) => offsetFilePath(sourcePath, extend, offset));
            }
            json.overrides?.forEach((o) => {
                if (o.parserOptions?.project) {
                    o.parserOptions.project = Array.isArray(o.parserOptions.project)
                        ? o.parserOptions.project.map((p) => p.replace(sourcePath, destinationPath))
                        : o.parserOptions.project.replace(sourcePath, destinationPath);
                }
            });
            return json;
        });
    }
}
exports.updateRelativePathsInConfig = updateRelativePathsInConfig;
function replaceFlatConfigPaths(config, sourceRoot, offset, destinationRoot) {
    let match;
    let newConfig = config;
    // replace requires
    const requireRegex = RegExp(/require\(['"](.*)['"]\)/g);
    while ((match = requireRegex.exec(newConfig)) !== null) {
        const newPath = offsetFilePath(sourceRoot, match[1], offset);
        newConfig =
            newConfig.slice(0, match.index) +
                `require('${newPath}')` +
                newConfig.slice(match.index + match[0].length);
    }
    // replace projects
    const projectRegex = RegExp(/project:\s?\[?['"](.*)['"]\]?/g);
    while ((match = projectRegex.exec(newConfig)) !== null) {
        const newProjectDef = match[0].replaceAll(sourceRoot, destinationRoot);
        newConfig =
            newConfig.slice(0, match.index) +
                newProjectDef +
                newConfig.slice(match.index + match[0].length);
    }
    return newConfig;
}
function offsetFilePath(projectRoot, pathToFile, offset) {
    if (!pathToFile.startsWith('..')) {
        // not a relative path
        return pathToFile;
    }
    return (0, devkit_1.joinPathFragments)(offset, projectRoot, pathToFile);
}
function addOverrideToLintConfig(tree, root, override, options = {
    insertAtTheEnd: true,
}) {
    const isBase = options.checkBaseConfig && findEslintFile(tree, root).includes('.base');
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? exports.baseEsLintFlatConfigFile : 'eslint.config.js');
        const flatOverride = (0, ast_utils_1.generateFlatOverride)(override, root);
        let content = tree.read(fileName, 'utf8');
        // we will be using compat here so we need to make sure it's added
        if (overrideNeedsCompat(override)) {
            content = (0, ast_utils_1.addCompatToFlatConfig)(content);
        }
        tree.write(fileName, (0, ast_utils_1.addBlockToFlatConfigExport)(content, flatOverride, options));
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? exports.baseEsLintConfigFile : '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.overrides ?? [];
            if (options.insertAtTheEnd) {
                json.overrides.push(override);
            }
            else {
                json.overrides.unshift(override);
            }
            return json;
        });
    }
}
exports.addOverrideToLintConfig = addOverrideToLintConfig;
function overrideNeedsCompat(override) {
    return (!override.env && !override.extends && !override.plugins && !override.parser);
}
function updateOverrideInLintConfig(tree, root, lookup, update) {
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, 'eslint.config.js');
        let content = tree.read(fileName, 'utf8');
        content = (0, ast_utils_1.replaceOverride)(content, root, lookup, update);
        tree.write(fileName, content);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            const index = json.overrides.findIndex(lookup);
            if (index !== -1) {
                json.overrides[index] = update(json.overrides[index]);
            }
            return json;
        });
    }
}
exports.updateOverrideInLintConfig = updateOverrideInLintConfig;
function lintConfigHasOverride(tree, root, lookup, checkBaseConfig = false) {
    if (!isEslintConfigSupported(tree, root)) {
        return false;
    }
    const isBase = checkBaseConfig && findEslintFile(tree, root).includes('.base');
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? exports.baseEsLintFlatConfigFile : 'eslint.config.js');
        const content = tree.read(fileName, 'utf8');
        return (0, ast_utils_1.hasOverride)(content, lookup);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, isBase ? exports.baseEsLintConfigFile : '.eslintrc.json');
        return (0, devkit_1.readJson)(tree, fileName).overrides?.some(lookup) || false;
    }
}
exports.lintConfigHasOverride = lintConfigHasOverride;
function replaceOverridesInLintConfig(tree, root, overrides) {
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, 'eslint.config.js');
        let content = tree.read(fileName, 'utf8');
        // we will be using compat here so we need to make sure it's added
        if (overrides.some(overrideNeedsCompat)) {
            content = (0, ast_utils_1.addCompatToFlatConfig)(content);
        }
        content = (0, ast_utils_1.removeOverridesFromLintConfig)(content);
        overrides.forEach((override) => {
            const flatOverride = (0, ast_utils_1.generateFlatOverride)(override, root);
            (0, ast_utils_1.addBlockToFlatConfigExport)(content, flatOverride);
        });
        tree.write(fileName, content);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.overrides = overrides;
            return json;
        });
    }
}
exports.replaceOverridesInLintConfig = replaceOverridesInLintConfig;
function addExtendsToLintConfig(tree, root, plugin) {
    const plugins = Array.isArray(plugin) ? plugin : [plugin];
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, 'eslint.config.js');
        const pluginExtends = (0, ast_utils_1.generatePluginExtendsElement)(plugins);
        tree.write(fileName, (0, ast_utils_1.addBlockToFlatConfigExport)(tree.read(fileName, 'utf8'), pluginExtends));
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.extends = [...plugins, ...(json.extends ?? [])];
            return json;
        });
    }
}
exports.addExtendsToLintConfig = addExtendsToLintConfig;
function addPluginsToLintConfig(tree, root, plugin) {
    const plugins = Array.isArray(plugin) ? plugin : [plugin];
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, 'eslint.config.js');
        let content = tree.read(fileName, 'utf8');
        const mappedPlugins = [];
        plugins.forEach((name) => {
            const imp = getPluginImport(name);
            const varName = (0, devkit_1.names)(imp).propertyName;
            mappedPlugins.push({ name, varName, imp });
        });
        mappedPlugins.forEach(({ varName, imp }) => {
            content = (0, ast_utils_1.addImportToFlatConfig)(content, varName, imp);
        });
        content = (0, ast_utils_1.addPluginsToExportsBlock)(content, mappedPlugins);
        tree.write(fileName, content);
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            json.plugins = [...plugins, ...(json.plugins ?? [])];
            return json;
        });
    }
}
exports.addPluginsToLintConfig = addPluginsToLintConfig;
function addIgnoresToLintConfig(tree, root, ignorePatterns) {
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        const fileName = (0, devkit_1.joinPathFragments)(root, 'eslint.config.js');
        const block = (0, ast_utils_1.generateAst)({
            ignores: ignorePatterns.map((path) => (0, ast_utils_1.mapFilePath)(path, root)),
        });
        tree.write(fileName, (0, ast_utils_1.addBlockToFlatConfigExport)(tree.read(fileName, 'utf8'), block));
    }
    else {
        const fileName = (0, devkit_1.joinPathFragments)(root, '.eslintrc.json');
        (0, devkit_1.updateJson)(tree, fileName, (json) => {
            const ignoreSet = new Set([
                ...(json.ignorePatterns ?? []),
                ...ignorePatterns,
            ]);
            json.ignorePatterns = Array.from(ignoreSet);
            return json;
        });
    }
}
exports.addIgnoresToLintConfig = addIgnoresToLintConfig;
function getPluginImport(pluginName) {
    if (pluginName.includes('eslint-plugin-')) {
        return pluginName;
    }
    if (!pluginName.startsWith('@')) {
        return `eslint-plugin-${pluginName}`;
    }
    if (!pluginName.includes('/')) {
        return `${pluginName}/eslint-plugin`;
    }
    const [scope, name] = pluginName.split('/');
    return `${scope}/eslint-plugin-${name}`;
}
exports.getPluginImport = getPluginImport;
