"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertEslintJsonToFlatConfig = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const ts = require("typescript");
const versions_1 = require("../../../utils/versions");
const ast_utils_1 = require("../../utils/flat-config/ast-utils");
const eslint_file_1 = require("../../utils/eslint-file");
/**
 * Converts an ESLint JSON config to a flat config.
 * Deletes the original file along with .eslintignore if it exists.
 */
function convertEslintJsonToFlatConfig(tree, root, sourceFile, destinationFile) {
    const importsMap = new Map();
    const exportElements = [];
    let isFlatCompatNeeded = false;
    let combinedConfig = [];
    let languageOptions = [];
    // read original config
    const config = (0, devkit_1.readJson)(tree, `${root}/${sourceFile}`);
    if (config.extends) {
        isFlatCompatNeeded = addExtends(importsMap, exportElements, config, tree);
    }
    if (config.plugins) {
        addPlugins(importsMap, exportElements, config);
    }
    if (config.parser) {
        const imp = config.parser;
        const parserName = (0, devkit_1.names)(imp).propertyName;
        importsMap.set(imp, parserName);
        languageOptions.push(ts.factory.createPropertyAssignment('parser', ts.factory.createIdentifier(parserName)));
    }
    if (config.parserOptions) {
        languageOptions.push(ts.factory.createPropertyAssignment('parserOptions', (0, ast_utils_1.generateAst)(config.parserOptions)));
    }
    if (config.globals || config.env) {
        if (config.env) {
            importsMap.set('globals', 'globals');
        }
        languageOptions.push(ts.factory.createPropertyAssignment('globals', ts.factory.createObjectLiteralExpression([
            ...Object.keys(config.env || {}).map((env) => ts.factory.createSpreadAssignment(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier('globals'), ts.factory.createIdentifier(env)))),
            ...Object.keys(config.globals || {}).map((key) => ts.factory.createPropertyAssignment(key, (0, ast_utils_1.generateAst)(config.globals[key]))),
        ])));
    }
    if (config.settings) {
        combinedConfig.push(ts.factory.createPropertyAssignment('settings', (0, ast_utils_1.generateAst)(config.settings)));
    }
    if (config.noInlineConfig !== undefined ||
        config.reportUnusedDisableDirectives !== undefined) {
        combinedConfig.push(ts.factory.createPropertyAssignment('linterOptions', (0, ast_utils_1.generateAst)({
            noInlineConfig: config.noInlineConfig,
            reportUnusedDisableDirectives: config.reportUnusedDisableDirectives,
        })));
    }
    if (languageOptions.length > 0) {
        combinedConfig.push(ts.factory.createPropertyAssignment('languageOptions', ts.factory.createObjectLiteralExpression(languageOptions, languageOptions.length > 1)));
    }
    if (combinedConfig.length > 0) {
        exportElements.push(ts.factory.createObjectLiteralExpression(combinedConfig, combinedConfig.length > 1));
    }
    if (config.rules) {
        exportElements.push((0, ast_utils_1.generateAst)({ rules: config.rules }));
    }
    if (config.overrides) {
        config.overrides.forEach((override) => {
            if (override.env ||
                override.extends ||
                override.plugins ||
                override.parser) {
                isFlatCompatNeeded = true;
            }
            exportElements.push((0, ast_utils_1.generateFlatOverride)(override, root));
        });
    }
    if (config.ignorePatterns) {
        const patterns = (Array.isArray(config.ignorePatterns)
            ? config.ignorePatterns
            : [config.ignorePatterns]).filter((pattern) => !['**/*', '!**/*', 'node_modules'].includes(pattern)); // these are useless in a flat config
        if (patterns.length > 0) {
            exportElements.push((0, ast_utils_1.generateAst)({
                ignores: patterns.map((path) => (0, ast_utils_1.mapFilePath)(path, root)),
            }));
        }
    }
    if (tree.exists(`${root}/.eslintignore`)) {
        const patterns = tree
            .read(`${root}/.eslintignore`, 'utf-8')
            .split('\n')
            .filter((line) => line.length > 0 && line !== 'node_modules')
            .map((path) => (0, ast_utils_1.mapFilePath)(path, root));
        if (patterns.length > 0) {
            exportElements.push((0, ast_utils_1.generateAst)({ ignores: patterns }));
        }
    }
    tree.delete((0, path_1.join)(root, sourceFile));
    tree.delete((0, path_1.join)(root, '.eslintignore'));
    // create the node list and print it to new file
    const nodeList = (0, ast_utils_1.createNodeList)(importsMap, exportElements, isFlatCompatNeeded);
    const content = (0, ast_utils_1.stringifyNodeList)(nodeList, root, destinationFile);
    tree.write((0, path_1.join)(root, destinationFile), content);
    if (isFlatCompatNeeded) {
        (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
            '@eslint/eslintrc': versions_1.eslintrcVersion,
        });
    }
}
exports.convertEslintJsonToFlatConfig = convertEslintJsonToFlatConfig;
// add parsed extends to export blocks and add import statements
function addExtends(importsMap, configBlocks, config, tree) {
    let isFlatCompatNeeded = false;
    const extendsConfig = Array.isArray(config.extends)
        ? config.extends
        : [config.extends];
    const eslintrcConfigs = [];
    // add base extends
    extendsConfig
        .filter((imp) => imp.match(/^\.?(\.\/)/))
        .forEach((imp, index) => {
        if (imp.match(/\.eslintrc(.base)?\.json$/)) {
            const localName = index ? `baseConfig${index}` : 'baseConfig';
            configBlocks.push((0, ast_utils_1.generateSpreadElement)(localName));
            const newImport = imp.replace(/^(.*)\.eslintrc(.base)?\.json$/, '$1eslint$2.config.js');
            importsMap.set(newImport, localName);
        }
        else {
            eslintrcConfigs.push(imp);
        }
    });
    // add plugin extends
    const pluginExtends = extendsConfig.filter((imp) => !imp.match(/^\.?(\.\/)/));
    if (pluginExtends.length) {
        const eslintPluginExtends = pluginExtends.filter((imp) => imp.startsWith('eslint:'));
        pluginExtends.forEach((imp) => {
            if (!imp.startsWith('eslint:')) {
                eslintrcConfigs.push(imp);
            }
        });
        if (eslintPluginExtends.length) {
            (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
                '@eslint/js': versions_1.eslintVersion,
            });
            importsMap.set('@eslint/js', 'js');
            eslintPluginExtends.forEach((plugin) => {
                configBlocks.push(ts.factory.createPropertyAccessExpression(ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier('js'), ts.factory.createIdentifier('configs')), ts.factory.createIdentifier(plugin.slice(7)) // strip 'eslint:' prefix
                ));
            });
        }
    }
    if (eslintrcConfigs.length) {
        isFlatCompatNeeded = true;
        (0, devkit_1.addDependenciesToPackageJson)(tree, {}, {
            '@eslint/js': versions_1.eslintVersion,
        });
        configBlocks.push((0, ast_utils_1.generatePluginExtendsElement)(eslintrcConfigs));
    }
    return isFlatCompatNeeded;
}
function addPlugins(importsMap, configBlocks, config) {
    const mappedPlugins = [];
    config.plugins.forEach((name) => {
        const imp = (0, eslint_file_1.getPluginImport)(name);
        const varName = (0, devkit_1.names)(imp).propertyName;
        mappedPlugins.push({ name, varName, imp });
    });
    mappedPlugins.forEach(({ varName, imp }) => {
        importsMap.set(imp, varName);
    });
    const pluginsAst = ts.factory.createObjectLiteralExpression([
        ts.factory.createPropertyAssignment('plugins', ts.factory.createObjectLiteralExpression(mappedPlugins.map(({ name, varName }) => {
            return ts.factory.createPropertyAssignment(ts.factory.createStringLiteral(name), ts.factory.createIdentifier(varName));
        }), mappedPlugins.length > 1)),
        ...(config.processor
            ? [
                ts.factory.createPropertyAssignment('processor', ts.factory.createStringLiteral(config.processor)),
            ]
            : []),
    ], false);
    configBlocks.push(pluginsAst);
}
