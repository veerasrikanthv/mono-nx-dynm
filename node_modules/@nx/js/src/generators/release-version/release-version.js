"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.releaseVersionGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const chalk = require("chalk");
const child_process_1 = require("child_process");
const version_1 = require("nx/src/command-line/release/version");
const utils_1 = require("nx/src/tasks-runner/utils");
const ora = require("ora");
const path_1 = require("path");
const resolve_local_package_dependencies_1 = require("./utils/resolve-local-package-dependencies");
async function releaseVersionGenerator(tree, options) {
    const projects = options.projects;
    // Resolve any custom package roots for each project upfront as they will need to be reused during dependency resolution
    const projectNameToPackageRootMap = new Map();
    for (const project of projects) {
        projectNameToPackageRootMap.set(project.name, 
        // Default to the project root if no custom packageRoot
        !options.packageRoot
            ? project.data.root
            : (0, utils_1.interpolate)(options.packageRoot, {
                workspaceRoot: '',
                projectRoot: project.data.root,
                projectName: project.name,
            }));
    }
    let currentVersion;
    for (const project of projects) {
        const projectName = project.name;
        const packageRoot = projectNameToPackageRootMap.get(projectName);
        const packageJsonPath = (0, devkit_1.joinPathFragments)(packageRoot, 'package.json');
        const workspaceRelativePackageJsonPath = (0, path_1.relative)(devkit_1.workspaceRoot, packageJsonPath);
        const color = getColor(projectName);
        const log = (msg) => {
            console.log(color.instance.bold(projectName) + ' ' + msg);
        };
        if (!tree.exists(packageJsonPath)) {
            throw new Error(`The project "${projectName}" does not have a package.json available at ${workspaceRelativePackageJsonPath}.
        
To fix this you will either need to add a package.json file at that location, or configure "release" within your nx.json to exclude "${projectName}" from the current release group, or amend the packageRoot configuration to point to where the package.json should be.`);
        }
        devkit_1.output.logSingleLine(`Running release version for project: ${color.instance.bold(project.name)}`);
        const projectPackageJson = (0, devkit_1.readJson)(tree, packageJsonPath);
        log(`🔍 Reading data for package "${projectPackageJson.name}" from ${workspaceRelativePackageJsonPath}`);
        const { name: packageName, version: currentVersionFromDisk } = projectPackageJson;
        switch (options.currentVersionResolver) {
            case 'registry': {
                const metadata = options.currentVersionResolverMetadata;
                const registry = metadata?.registry ?? 'https://registry.npmjs.org';
                const tag = metadata?.tag ?? 'latest';
                // If the currentVersionResolver is set to registry, we only want to make the request once for the whole batch of projects
                if (!currentVersion) {
                    const spinner = ora(`${Array.from(new Array(projectName.length + 3)).join(' ')}Resolving the current version for tag "${tag}" on ${registry}`);
                    spinner.color =
                        color.spinnerColor;
                    spinner.start();
                    // Must be non-blocking async to allow spinner to render
                    currentVersion = await new Promise((resolve, reject) => {
                        (0, child_process_1.exec)(`npm view ${packageName} version --registry=${registry} --tag=${tag}`, (error, stdout, stderr) => {
                            if (error) {
                                return reject(error);
                            }
                            if (stderr) {
                                return reject(stderr);
                            }
                            return resolve(stdout.trim());
                        });
                    });
                    spinner.stop();
                    log(`📄 Resolved the current version as ${currentVersion} for tag "${tag}" from registry ${registry}`);
                }
                else {
                    log(`📄 Using the current version ${currentVersion} already resolved from the registry ${registry}`);
                }
                break;
            }
            case 'disk':
                currentVersion = currentVersionFromDisk;
                log(`📄 Resolved the current version as ${currentVersion} from ${packageJsonPath}`);
                break;
            default:
                throw new Error(`Invalid value for options.currentVersionResolver: ${options.currentVersionResolver}`);
        }
        // Resolve any local package dependencies for this project (before applying the new version)
        const localPackageDependencies = (0, resolve_local_package_dependencies_1.resolveLocalPackageDependencies)(tree, options.projectGraph, projects, projectNameToPackageRootMap);
        const newVersion = (0, version_1.deriveNewSemverVersion)(currentVersion, options.specifier, options.preid);
        (0, devkit_1.writeJson)(tree, packageJsonPath, {
            ...projectPackageJson,
            version: newVersion,
        });
        log(`✍️  New version ${newVersion} written to ${workspaceRelativePackageJsonPath}`);
        const dependentProjects = Object.values(localPackageDependencies)
            .filter((localPackageDependencies) => {
            return localPackageDependencies.some((localPackageDependency) => localPackageDependency.target === project.name);
        })
            .flat();
        if (dependentProjects.length > 0) {
            log(`✍️  Applying new version ${newVersion} to ${dependentProjects.length} ${dependentProjects.length > 1
                ? 'packages which depend'
                : 'package which depends'} on ${project.name}`);
        }
        for (const dependentProject of dependentProjects) {
            (0, devkit_1.updateJson)(tree, (0, devkit_1.joinPathFragments)(projectNameToPackageRootMap.get(dependentProject.source), 'package.json'), (json) => {
                json[dependentProject.dependencyCollection][packageName] = newVersion;
                return json;
            });
        }
    }
}
exports.releaseVersionGenerator = releaseVersionGenerator;
exports.default = releaseVersionGenerator;
const colors = [
    { instance: chalk.green, spinnerColor: 'green' },
    { instance: chalk.greenBright, spinnerColor: 'green' },
    { instance: chalk.red, spinnerColor: 'red' },
    { instance: chalk.redBright, spinnerColor: 'red' },
    { instance: chalk.cyan, spinnerColor: 'cyan' },
    { instance: chalk.cyanBright, spinnerColor: 'cyan' },
    { instance: chalk.yellow, spinnerColor: 'yellow' },
    { instance: chalk.yellowBright, spinnerColor: 'yellow' },
    { instance: chalk.magenta, spinnerColor: 'magenta' },
    { instance: chalk.magentaBright, spinnerColor: 'magenta' },
];
function getColor(projectName) {
    let code = 0;
    for (let i = 0; i < projectName.length; ++i) {
        code += projectName.charCodeAt(i);
    }
    const colorIndex = code % colors.length;
    return colors[colorIndex];
}
