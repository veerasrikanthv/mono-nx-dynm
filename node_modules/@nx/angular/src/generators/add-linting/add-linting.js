"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addLintingGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const linter_1 = require("@nx/linter");
const lint_project_1 = require("@nx/linter/src/generators/lint-project/lint-project");
const add_angular_eslint_dependencies_1 = require("./lib/add-angular-eslint-dependencies");
const eslint_file_1 = require("@nx/linter/src/generators/utils/eslint-file");
const string_utils_1 = require("@nx/devkit/src/utils/string-utils");
async function addLintingGenerator(tree, options) {
    const tasks = [];
    const rootProject = options.projectRoot === '.' || options.projectRoot === '';
    const lintTask = await (0, linter_1.lintProjectGenerator)(tree, {
        linter: linter_1.Linter.EsLint,
        project: options.projectName,
        tsConfigPaths: [
            (0, devkit_1.joinPathFragments)(options.projectRoot, 'tsconfig.app.json'),
        ],
        unitTestRunner: options.unitTestRunner,
        eslintFilePatterns: [
            (0, lint_project_1.mapLintPattern)(options.projectRoot, 'ts', rootProject),
            (0, lint_project_1.mapLintPattern)(options.projectRoot, 'html', rootProject),
        ],
        setParserOptionsProject: options.setParserOptionsProject,
        skipFormat: true,
        rootProject: rootProject,
    });
    tasks.push(lintTask);
    if ((0, eslint_file_1.isEslintConfigSupported)(tree)) {
        const eslintFile = (0, eslint_file_1.findEslintFile)(tree, options.projectRoot);
        // keep parser options if they exist
        const hasParserOptions = tree
            .read((0, devkit_1.joinPathFragments)(options.projectRoot, eslintFile), 'utf8')
            .includes(`${options.projectRoot}/tsconfig.*?.json`);
        (0, eslint_file_1.replaceOverridesInLintConfig)(tree, options.projectRoot, [
            {
                files: ['*.ts'],
                ...(hasParserOptions
                    ? {
                        parserOptions: {
                            project: [`${options.projectRoot}/tsconfig.*?.json`],
                        },
                    }
                    : {}),
                extends: [
                    'plugin:@nx/angular',
                    'plugin:@angular-eslint/template/process-inline-templates',
                ],
                rules: {
                    '@angular-eslint/directive-selector': [
                        'error',
                        {
                            type: 'attribute',
                            prefix: (0, string_utils_1.camelize)(options.prefix),
                            style: 'camelCase',
                        },
                    ],
                    '@angular-eslint/component-selector': [
                        'error',
                        {
                            type: 'element',
                            prefix: (0, string_utils_1.dasherize)(options.prefix),
                            style: 'kebab-case',
                        },
                    ],
                },
            },
            {
                files: ['*.html'],
                extends: ['plugin:@nx/angular-template'],
                /**
                 * Having an empty rules object present makes it more obvious to the user where they would
                 * extend things from if they needed to
                 */
                rules: {},
            },
            ...(isBuildableLibraryProject(tree, options.projectName)
                ? [
                    {
                        files: ['*.json'],
                        parser: 'jsonc-eslint-parser',
                        rules: {
                            '@nx/dependency-checks': 'error',
                        },
                    },
                ]
                : []),
        ]);
    }
    if (!options.skipPackageJson) {
        const installTask = (0, add_angular_eslint_dependencies_1.addAngularEsLintDependencies)(tree);
        tasks.push(installTask);
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.addLintingGenerator = addLintingGenerator;
function isBuildableLibraryProject(tree, projectName) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    return (projectConfig.projectType === 'library' &&
        projectConfig.targets?.build &&
        !!projectConfig.targets.build);
}
exports.default = addLintingGenerator;
